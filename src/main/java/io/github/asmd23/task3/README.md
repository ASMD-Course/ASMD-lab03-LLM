# TASK 3

## Part 1.
First, I've analyzed the exercise specification and the provided code along with the interface. For convenience, I've
added a new constructor to LogicsImpl that allows me to pass the position of the knight and pawn directly, instead of
generating them randomly. This makes it easier to test specific scenarios.

I asked Copilot then to generate me a test class for the `LogicsImpl` class, which is the main logic of the game.
The test added initially are:
- `testKnightAndPawnInitialPositions`
- `testValidKnightMoveAndHit` -> Doesn't pass because the knight's move performed is not valid.
- `testInvalidKnightMove`
- `testOutOfBoundsThrows`
- `testConstructorThrowsOnInvalidPositions`

These cover the basic functionality, but they don't cover all edge cases. Also, tests are not structured well
(missing @BeforeEach, @AfterEach, @Nested, etc.).

Manually subdivided test in Nested classes to improve readability and maintainability:
- `Initialization` -> Covers initial setup and constructor behavior.
- `Movement` -> Covers valid and invalid knight moves.
- `Finalization` -> Covers game end conditions and pawn capture.

Given this subdivision, I asked Copilot to generate more tests for each of these categories. 

## Part 2.
I've analyzed the actual implementation of the `LogicsImpl` class and the interface trying to find if any component could
be externalized:
- `Logger` -> Used for logging game events or any relevant information.

First I've added the `Logger`interface and its implementation, which allows for different logging strategies (e.g., console, file, etc.).
I've added tests for the `Logger` class to ensure it works correctly. These were generated by Copilot and cover the basic functionality 
that the logger should provide. As usually, the methods don't cover all cases (e.g. there aren't tests for checking null values).
I've added manually and then integrated in the LogicsImpl class.





